package com.vulnview.service;

import com.vulnview.dto.ComponentToEnrich;
import com.vulnview.dto.vulnerability.VulnerabilityDataDto;
import com.vulnview.dto.graph.GraphDataResponse;
import com.vulnview.dto.graph.GraphNode;
import com.vulnview.dto.graph.GraphLink;
import com.vulnview.entity.Build;
import com.vulnview.entity.BuildStatus;
import com.vulnview.entity.Component;
import com.vulnview.entity.ComponentVulnerability;
import com.vulnview.entity.Vulnerability;
import com.vulnview.entity.RiskLevel;
import com.vulnview.entity.Sbom;
import com.vulnview.exception.ResourceNotFoundException;
import com.vulnview.repository.BuildRepository;
import com.vulnview.repository.ComponentRepository;
import com.vulnview.repository.ComponentVulnerabilityRepository;
import com.vulnview.repository.VulnerabilityRepository;
import com.vulnview.repository.SbomRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.retry.annotation.Recover;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.Collections;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.stream.Collectors;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Consumer;
import java.util.Date;
import com.vulnview.model.ScanProgress;
import java.time.ZoneId;

@Slf4j
@Service
@RequiredArgsConstructor
public class VulnerabilityScanService {
    private final ComponentRepository componentRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ComponentVulnerabilityRepository componentVulnerabilityRepository;
    private final BuildRepository buildRepository;
    private final VulnerabilityEnrichmentService enrichmentService;
    private final NvdApiService nvdApiService;
    private final RestTemplate restTemplate;
    private final SbomRepository sbomRepository;
    private final ExecutorService executorService = Executors.newFixedThreadPool(10);
    private final Map<String, CompletableFuture<Void>> enrichmentTasks = new ConcurrentHashMap<>();
    
    @Value("${vulnview.nvd.api.base-url}")
    private String nvdApiBaseUrl;

    private final Map<String, ScanProgress> scanProgressMap = new ConcurrentHashMap<>();
    private static final long SCAN_CLEANUP_THRESHOLD = 24 * 60 * 60 * 1000; // 24 hours

    @Transactional
    public void scanComponentForVulnerabilities(Component component) {
        log.info("Scanning component {} for vulnerabilities", component.getName());
        
        Component savedComponent = componentRepository.save(component);
        log.info("Component saved with ID: {}", savedComponent.getId());
        
        ComponentToEnrich componentToEnrich = createComponentToEnrich(savedComponent);
            
        try {
            Thread.sleep(1000); // 1 second delay
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.warn("Scan delay interrupted for component: {}", savedComponent.getName());
        }
            
        enrichmentService.enrichComponent(componentToEnrich, result -> {
            if (result != null && result.containsKey("vulnerabilities")) {
                @SuppressWarnings("unchecked")
                List<VulnerabilityDataDto> vulnerabilities = (List<VulnerabilityDataDto>) result.get("vulnerabilities");
                for (VulnerabilityDataDto vuln : vulnerabilities) {
                    processVulnerability(vuln, savedComponent);
                }
            }
        });
    }

    private ComponentToEnrich createComponentToEnrich(Component component) {
        log.info("Creating ComponentToEnrich for component: name={}, version={}, type={}, packageUrl={}", 
            component.getName(), component.getVersion(), component.getType(), component.getPackageUrl());

        String packageUrl = component.getPackageUrl();
        if (packageUrl == null || packageUrl.isEmpty()) {
            if ("npm".equals(component.getType())) {
                if (component.getGroupName() != null && !component.getGroupName().isEmpty()) {
                    packageUrl = String.format("pkg:npm/%s/%s@%s", 
                        component.getGroupName(), component.getName(), component.getVersion());
                } else {
                    packageUrl = String.format("pkg:npm/%s@%s", 
                        component.getName(), component.getVersion());
                }
                log.debug("Constructed package URL for npm package: {}", packageUrl);
            } else {
                log.warn("No package URL available for non-npm component: name={}, type={}", 
                    component.getName(), component.getType());
            }
        }

        return ComponentToEnrich.builder()
            .id(component.getId())
            .name(component.getName())
            .version(component.getVersion())
            .type(component.getType())
            .purl(packageUrl)
            .sbomId(component.getSbom() != null ? component.getSbom().getId() : null)
            .callback(response -> {
                if (response != null && response.containsKey("vulnerabilities")) {
                    @SuppressWarnings("unchecked")
                    List<VulnerabilityDataDto> vulnerabilities = (List<VulnerabilityDataDto>) response.get("vulnerabilities");
                    for (VulnerabilityDataDto vuln : vulnerabilities) {
                        processVulnerability(vuln, component);
                    }
                }
            })
            .build();
    }

    @Async
    public void enrichComponents(List<Component> components) {
        log.info("Starting enrichment for {} components", components.size());
        
        List<ComponentToEnrich> componentsToEnrich = components.stream()
            .map(this::createComponentToEnrich)
            .collect(Collectors.toList());

        log.debug("Created {} ComponentToEnrich objects", componentsToEnrich.size());

        for (ComponentToEnrich componentToEnrich : componentsToEnrich) {
            try {
                Component component = componentRepository.findById(componentToEnrich.getId())
                    .orElseThrow(() -> new RuntimeException("Component not found: " + componentToEnrich.getId()));

                enrichmentService.enrichComponent(componentToEnrich, result -> {
                    if (result != null && result.containsKey("vulnerabilities")) {
                        @SuppressWarnings("unchecked")
                        List<VulnerabilityDataDto> vulnerabilities = (List<VulnerabilityDataDto>) result.get("vulnerabilities");
                        for (VulnerabilityDataDto vuln : vulnerabilities) {
                            processVulnerability(vuln, component);
                        }
                    }
                });
            } catch (Exception e) {
                log.error("Error enriching component: name={}, version={}, type={}, error={}", 
                    componentToEnrich.getName(), componentToEnrich.getVersion(), componentToEnrich.getType(), e.getMessage(), e);
            }
        }
        
        log.info("Completed enrichment process for {} components", components.size());
    }

    private void processVulnerability(VulnerabilityDataDto vuln, Component component) {
        if (vuln == null || vuln.getCveId() == null) {
            log.warn("Skipping null vulnerability or CVE ID for component: {}", component.getName());
            return;
        }

        Vulnerability vulnerability = vulnerabilityRepository.findByCveId(vuln.getCveId())
                .orElseGet(() -> createVulnerability(vuln));

        ComponentVulnerability componentVulnerability = ComponentVulnerability.builder()
            .component(component)
            .vulnerability(vulnerability)
            .sbom(component.getSbom())
            .description(vuln.getDescription())
            .score(vuln.getCvssScore())
            .severity(vuln.getSeverity())
            .build();
        componentVulnerabilityRepository.save(componentVulnerability);
    }

    private Vulnerability createVulnerability(VulnerabilityDataDto vuln) {
        Vulnerability vulnerability = Vulnerability.builder()
            .cveId(vuln.getCveId())
            .description(vuln.getDescription())
            .cvssScore(vuln.getCvssScore())
            .severity(vuln.getSeverity())
            .build();
        return vulnerabilityRepository.save(vulnerability);
    }

    @Async
    public void scanAllComponentsAsync(String scanId) {
        log.info("Starting async scan with ID: {}", scanId);
        ScanProgress progress = new ScanProgress();
        progress.setTotalComponents(0);
        progress.setProcessedComponents(0);
        progress.setStatus("IN_PROGRESS");
        scanProgressMap.put(scanId, progress);

        try {
            List<Component> components = componentRepository.findAll();
            progress.setTotalComponents(components.size());
            scanProgressMap.put(scanId, progress);

            for (Component component : components) {
                try {
                    scanComponentForVulnerabilities(component);
                    progress.incrementProcessedComponents();
                    scanProgressMap.put(scanId, progress);
                } catch (Exception e) {
                    log.error("Error scanning component: {}", component.getName(), e);
                }
            }

            progress.setStatus("COMPLETED");
            scanProgressMap.put(scanId, progress);
        } catch (Exception e) {
            log.error("Error in scanAllComponentsAsync: {}", e.getMessage(), e);
            progress.setStatus("FAILED");
            progress.setErrorMessage(e.getMessage());
            scanProgressMap.put(scanId, progress);
        }
    }

    @Scheduled(fixedRate = 3600000) // Run every hour
    public void cleanupCompletedScans() {
        log.info("Starting cleanup of completed scans");
        long currentTime = System.currentTimeMillis();
        
        scanProgressMap.entrySet().removeIf(entry -> {
            ScanProgress progress = entry.getValue();
            return progress.getStatus().equals("COMPLETED") && 
                   (currentTime - progress.getLastUpdated().atZone(ZoneId.systemDefault()).toInstant().toEpochMilli()) > SCAN_CLEANUP_THRESHOLD;
        });
        
        log.info("Completed cleanup of old scans");
    }

    public ScanProgress getProgress(String scanId) {
        return scanProgressMap.get(scanId);
    }

    public Map<String, Object> getScanResults(String scanId) {
        ScanProgress progress = scanProgressMap.get(scanId);
        if (progress == null) {
            return Collections.emptyMap();
        }

        List<Component> components = componentRepository.findAll();
        return createScanResult(progress, components);
    }

    private Map<String, Object> createScanResult(ScanProgress progress, List<Component> components) {
        Map<String, Object> result = new HashMap<>();
        result.put("status", progress.getStatus());
        result.put("totalComponents", progress.getTotalComponents());
        result.put("processedComponents", progress.getProcessedComponents());
        result.put("components", components);
        return result;
    }

    public String startScanForSbom(Long sbomId) {
        String scanId = String.format("sbom_%d_%s", sbomId, UUID.randomUUID().toString());
        log.info("Starting scan for SBOM {} with scan ID: {}", sbomId, scanId);
        
        ScanProgress progress = new ScanProgress();
        progress.setStatus("IN_PROGRESS");
        scanProgressMap.put(scanId, progress);
        
        CompletableFuture.runAsync(() -> scanSbomComponents(sbomId, scanId), executorService);
        return scanId;
    }

    @Transactional
    private void scanSbomComponents(Long sbomId, String scanId) {
        try {
            Sbom sbom = sbomRepository.findById(sbomId)
                .orElseThrow(() -> new ResourceNotFoundException("SBOM not found with id: " + sbomId));
            // Fetch components eagerly using repository
            List<Component> components = componentRepository.findBySbomId(sbomId);
            if (components.isEmpty()) {
                log.warn("No components found in SBOM {}", sbomId);
                ScanProgress progress = scanProgressMap.get(scanId);
                progress.setStatus("COMPLETED");
                progress.setTotalComponents(0);
                progress.setProcessedComponents(0);
                scanProgressMap.put(scanId, progress);
                return;
            }
            ScanProgress progress = scanProgressMap.get(scanId);
            progress.setTotalComponents(components.size());
            scanProgressMap.put(scanId, progress);
            for (Component component : components) {
                try {
                    log.info("Scanning component: {} (version: {})", component.getName(), component.getVersion());
                    ComponentToEnrich componentToEnrich = ComponentToEnrich.builder()
                        .id(component.getId())
                        .name(component.getName())
                        .version(component.getVersion())
                        .type(component.getType())
                        .purl(component.getPackageUrl())
                        .build();
                    enrichmentService.enrichComponent(componentToEnrich, result -> {
                        if (result != null && result.containsKey("vulnerabilities")) {
                            @SuppressWarnings("unchecked")
                            List<VulnerabilityDataDto> vulnerabilities = (List<VulnerabilityDataDto>) result.get("vulnerabilities");
                            for (VulnerabilityDataDto vuln : vulnerabilities) {
                                processVulnerability(vuln, component);
                            }
                        }
                    });
                    progress.incrementProcessedComponents();
                    scanProgressMap.put(scanId, progress);
                    Thread.sleep(1000);
                } catch (Exception e) {
                    log.error("Error scanning component: {} - {}", component.getName(), e.getMessage(), e);
                }
            }
            progress.setStatus("COMPLETED");
            scanProgressMap.put(scanId, progress);
            log.info("Completed scanning SBOM {} with {} components", sbomId, components.size());
        } catch (Exception e) {
            log.error("Error in scanSbomComponents: {}", e.getMessage(), e);
            ScanProgress progress = scanProgressMap.get(scanId);
            progress.setStatus("FAILED");
            progress.setErrorMessage(e.getMessage());
            scanProgressMap.put(scanId, progress);
        }
    }

    public List<ComponentVulnerability> getComponentVulnerabilities(Component component) {
        return componentVulnerabilityRepository.findByComponentIdIn(Collections.singletonList(component.getId()));
    }

    public void updateComponentRiskLevel(Component component) {
        List<ComponentVulnerability> vulnerabilities = getComponentVulnerabilities(component);
        RiskLevel highestRisk = vulnerabilities.stream()
            .map(v -> RiskLevel.fromString(v.getSeverity()))
            .max(RiskLevel::compareTo)
            .orElse(RiskLevel.UNKNOWN);
        
        component.setRiskLevel(highestRisk);
        componentRepository.save(component);
    }

    public String getStatusForBuild(String buildId) {
        // TODO: Implement actual status lookup
        return "NOT_IMPLEMENTED";
    }

    public String startScan() {
        String scanId = UUID.randomUUID().toString();
        CompletableFuture.runAsync(() -> scanAllComponentsAsync(scanId), executorService);
        return scanId;
    }

    public Map<String, Object> getSbomData(Long sbomId) {
        Sbom sbom = sbomRepository.findById(sbomId)
            .orElseThrow(() -> new ResourceNotFoundException("SBOM not found with id: " + sbomId));
        
        Map<String, Object> data = new HashMap<>();
        data.put("id", sbom.getId());
        data.put("version", sbom.getVersion());
        data.put("serialNumber", sbom.getSerialNumber());
        data.put("bomFormat", sbom.getBomFormat());
        data.put("specVersion", sbom.getSpecVersion());
        data.put("components", sbom.getComponents());
        return data;
    }
}