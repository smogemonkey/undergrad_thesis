package com.vulnview.service.impl;

import com.vulnview.dto.vulnerability.VulnerabilityResponse;
import com.vulnview.entity.Component;
import com.vulnview.entity.Project;
import com.vulnview.entity.Vulnerability;
import com.vulnview.repository.ComponentRepository;
import com.vulnview.repository.ProjectRepository;
import com.vulnview.repository.VulnerabilityRepository;
import com.vulnview.service.AiService;
import com.vulnview.service.VulnerabilityExportService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.ByteArrayOutputStream;
import java.util.*;
import java.util.stream.Collectors;

import com.vulnview.enums.ExportFormat;

@Slf4j
@Service
@RequiredArgsConstructor
public class VulnerabilityExportServiceImpl implements VulnerabilityExportService {

    private final ProjectRepository projectRepository;
    private final ComponentRepository componentRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final AiService aiService;

    @Override
    @Transactional(readOnly = true)
    public byte[] generateExcelReport(Long projectId) {
        try (Workbook workbook = new XSSFWorkbook()) {
            Project project = projectRepository.findById(projectId)
                    .orElseThrow(() -> new RuntimeException("Project not found"));

            // Create summary sheet
            Sheet summarySheet = workbook.createSheet("Summary");
            createSummarySheet(summarySheet, project);

            // Create components sheet
            Sheet componentsSheet = workbook.createSheet("Components");
            createComponentsSheet(componentsSheet, project);

            // Create vulnerabilities sheet
            Sheet vulnerabilitiesSheet = workbook.createSheet("Vulnerabilities");
            createVulnerabilitiesSheet(vulnerabilitiesSheet, project);

            // Create AI recommendations sheet
            Sheet recommendationsSheet = workbook.createSheet("AI Recommendations");
            createRecommendationsSheet(recommendationsSheet, project);

            // Write to byte array
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            workbook.write(outputStream);
            return outputStream.toByteArray();

        } catch (Exception e) {
            log.error("Error generating Excel report", e);
            throw new RuntimeException("Failed to generate Excel report", e);
        }
    }

    private void createSummarySheet(Sheet sheet, Project project) {
        // Create header row
        Row headerRow = sheet.createRow(0);
        headerRow.createCell(0).setCellValue("Project Summary");
        headerRow.createCell(1).setCellValue(project.getName());

        // Add project details
        int rowNum = 2;
        createSummaryRow(sheet, rowNum++, "Total Components", 
            String.valueOf(componentRepository.countByProject(project)));
        createSummaryRow(sheet, rowNum++, "Vulnerable Components", 
            String.valueOf(componentRepository.countVulnerableComponentsByProject(project)));
        createSummaryRow(sheet, rowNum++, "Total Vulnerabilities", 
            String.valueOf(vulnerabilityRepository.countByProject(project)));
    }

    private void createComponentsSheet(Sheet sheet, Project project) {
        // Create header row
        Row headerRow = sheet.createRow(0);
        String[] headers = {"Component Name", "Version", "Type", "Vulnerability Count", "Risk Level"};
        for (int i = 0; i < headers.length; i++) {
            headerRow.createCell(i).setCellValue(headers[i]);
        }

        // Add component data
        List<Component> components = componentRepository.findByProject(project);
        int rowNum = 1;
        for (Component component : components) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(component.getName());
            row.createCell(1).setCellValue(component.getVersion());
            row.createCell(2).setCellValue(component.getType());
            row.createCell(3).setCellValue(component.getComponentVulnerabilities().size());
            row.createCell(4).setCellValue(getHighestRiskLevel(component));
        }
    }

    private void createVulnerabilitiesSheet(Sheet sheet, Project project) {
        // Create header row
        Row headerRow = sheet.createRow(0);
        String[] headers = {"CVE ID", "Component", "Severity", "Description", "Fix Version"};
        for (int i = 0; i < headers.length; i++) {
            headerRow.createCell(i).setCellValue(headers[i]);
        }

        // Add vulnerability data
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findByProject(project);
        int rowNum = 1;
        for (Vulnerability vuln : vulnerabilities) {
            for (Component component : vuln.getComponents()) {
                Row row = sheet.createRow(rowNum++);
                row.createCell(0).setCellValue(vuln.getCveId());
                row.createCell(1).setCellValue(component.getName());
                row.createCell(2).setCellValue(vuln.getSeverity().toString());
                row.createCell(3).setCellValue(vuln.getDescription());
                row.createCell(4).setCellValue(vuln.getFixVersion());
            }
        }
    }

    private void createRecommendationsSheet(Sheet sheet, Project project) {
        // Create header row
        Row headerRow = sheet.createRow(0);
        String[] headers = {"Component", "Current Version", "Recommended Version", "Reason"};
        for (int i = 0; i < headers.length; i++) {
            headerRow.createCell(i).setCellValue(headers[i]);
        }

        // Get AI recommendations
        List<Component> vulnerableComponents = componentRepository.findVulnerableComponentsByProject(project);
        var aiResponse = aiService.generateVulnerabilitySummary(vulnerableComponents);

        // Add recommendations
        int rowNum = 1;
        for (Component component : vulnerableComponents) {
            Row row = sheet.createRow(rowNum++);
            row.createCell(0).setCellValue(component.getName());
            row.createCell(1).setCellValue(component.getVersion());
            // Add AI recommendations here
            row.createCell(2).setCellValue("See AI Summary");
            row.createCell(3).setCellValue(aiResponse.getSummary());
        }
    }

    private void createSummaryRow(Sheet sheet, int rowNum, String label, String value) {
        Row row = sheet.createRow(rowNum);
        row.createCell(0).setCellValue(label);
        row.createCell(1).setCellValue(value);
    }

    private String getHighestRiskLevel(Component component) {
        return component.getComponentVulnerabilities().stream()
                .map(cv -> cv.getVulnerability().getSeverity())
                .filter(Objects::nonNull)
                .max(String::compareTo)
                .orElse("NONE");
    }

    @Override
    public Map<String, Object> compareVulnerabilities(Long repositoryId, String baselineVersion, String currentVersion) {
        // Implementation for comparing vulnerabilities between versions
        return new HashMap<>();
    }

    @Override
    public List<Map<String, Object>> getVulnerabilityHistory(Long repositoryId) {
        // Implementation for getting vulnerability history
        return new ArrayList<>();
    }

    @Override
    public byte[] exportVulnerabilities(Long projectId, ExportFormat format) {
        switch (format) {
            case EXCEL:
                return generateExcelReport(projectId);
            case PDF:
                // TODO: Implement PDF export
                return new byte[0];
            default:
                throw new IllegalArgumentException("Unsupported export format: " + format);
        }
    }
} 