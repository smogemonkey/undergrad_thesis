package com.vulnview.service.impl;

import com.vulnview.dto.vulnerability.ComponentReportDto;
import com.vulnview.dto.vulnerability.VulnerabilityResponse;
import com.vulnview.entity.Component;
import com.vulnview.entity.Vulnerability;
import com.vulnview.entity.RiskLevel;
import com.vulnview.exception.NotFoundException;
import com.vulnview.repository.ComponentRepository;
import com.vulnview.repository.VulnerabilityRepository;
import com.vulnview.service.VulnerabilityService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class VulnerabilityServiceImpl implements VulnerabilityService {
    private final RestTemplate restTemplate;
    private final ComponentRepository componentRepository;
    private final VulnerabilityRepository vulnerabilityRepository;

    @Value("${ossindex.username}")
    private String ossindexUsername;

    @Value("${ossindex.token}")
    private String ossindexToken;

    @Override
    @Transactional
    public Vulnerability createVulnerability(Vulnerability vulnerability) {
        return vulnerabilityRepository.save(vulnerability);
    }

    @Override
    @Transactional
    public Vulnerability updateVulnerability(Long id, Vulnerability vulnerability) {
        Vulnerability existingVulnerability = vulnerabilityRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Vulnerability not found with id: " + id));
        
        existingVulnerability.setCveId(vulnerability.getCveId());
        existingVulnerability.setDescription(vulnerability.getDescription());
        existingVulnerability.setRemediation(vulnerability.getRemediation());
        existingVulnerability.setRiskLevel(vulnerability.getRiskLevel());
        existingVulnerability.setPublishedDate(vulnerability.getPublishedDate());
        existingVulnerability.setLastModifiedDate(vulnerability.getLastModifiedDate());
        
        return vulnerabilityRepository.save(existingVulnerability);
    }

    @Override
    @Transactional
    public void deleteVulnerability(Long id) {
        if (!vulnerabilityRepository.existsById(id)) {
            throw new NotFoundException("Vulnerability not found with id: " + id);
        }
        vulnerabilityRepository.deleteById(id);
    }

    @Override
    @Transactional(readOnly = true)
    public Vulnerability getVulnerabilityById(Long id) {
        return vulnerabilityRepository.findById(id)
                .orElseThrow(() -> new NotFoundException("Vulnerability not found with id: " + id));
    }

    @Override
    @Transactional(readOnly = true)
    public Vulnerability getVulnerabilityByCveId(String cveId) {
        return vulnerabilityRepository.findByCveId(cveId)
                .orElseThrow(() -> new NotFoundException("Vulnerability not found with CVE ID: " + cveId));
    }

    @Override
    @Transactional(readOnly = true)
    public Page<Vulnerability> getAllVulnerabilities(Pageable pageable) {
        return vulnerabilityRepository.findAll(pageable);
    }

    @Override
    @Transactional(readOnly = true)
    public List<Vulnerability> getVulnerabilitiesByRiskLevel(RiskLevel riskLevel) {
        return vulnerabilityRepository.findByRiskLevel(riskLevel);
    }

    @Override
    @Transactional
    public List<ComponentReportDto> getVulnerabilityByComponentPurl(List<String> purls) {
        List<ComponentReportDto> result = new ArrayList<>();
        if (!purls.isEmpty()) {
            for (int i = 0; i <= purls.size() / 128; i++) {
                List<String> purlsBatch = purls.subList(i * 128, Math.min((i + 1) * 128, purls.size()));
                Map<String, List<String>> requestBody = Map.of("coordinates", purlsBatch);
                
                // Create authentication header
                String auth = ossindexUsername + ":" + ossindexToken;
                String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes());
                HttpHeaders headers = new HttpHeaders();
                headers.add("Authorization", "Basic " + encodedAuth);
                
                HttpEntity<Map<String, List<String>>> request = new HttpEntity<>(requestBody, headers);
                String url = "https://ossindex.sonatype.org/api/v3/component-report";
                
                try {
                    ResponseEntity<List<ComponentReportDto>> response = restTemplate.exchange(
                        url, 
                        HttpMethod.POST, 
                        request, 
                        new ParameterizedTypeReference<>() {}
                    );
                    
                    List<ComponentReportDto> componentReports = response.getBody();
                    if (componentReports != null) {
                        result.addAll(componentReports);
                        // Save vulnerabilities for each component
                        saveVulnerabilityReport(componentReports);
                    }
                } catch (Exception e) {
                    // Log the error but continue processing other batches
                    System.err.println("Error processing batch: " + e.getMessage());
                }
            }
        }
        return result;
    }

    @Override
    @Transactional
    public void saveVulnerabilityReport(List<ComponentReportDto> componentReports) {
        componentReports.forEach(componentReport -> {
            Component component = componentRepository.findByPackageUrl(componentReport.getCoordinates());
            if (component != null) {
                componentReport.getVulnerabilities().forEach(vulnerabilityDto -> {
                    Vulnerability vulnerability = vulnerabilityRepository.findByCveId(vulnerabilityDto.getCve())
                            .orElseGet(() -> {
                                Vulnerability newVuln = new Vulnerability();
                                newVuln.setCveId(vulnerabilityDto.getCve());
                                newVuln.setTitle(vulnerabilityDto.getTitle());
                                newVuln.setDescription(vulnerabilityDto.getDescription());
                                newVuln.setCvssScore(String.valueOf(vulnerabilityDto.getCvssScore()));
                                newVuln.setCvssVector(vulnerabilityDto.getCvssVector());
                                newVuln.setCwe(vulnerabilityDto.getCwe());
                                newVuln.setReference(vulnerabilityDto.getReference());
                                return newVuln;
                            });
                    vulnerability.addComponent(component);
                    vulnerabilityRepository.save(vulnerability);
                });
            }
        });
    }

    @Override
    public List<VulnerabilityResponse> getAllVulnerabilitiesResponse() {
        return vulnerabilityRepository.findAll().stream()
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    @Override
    public VulnerabilityResponse getVulnerabilityByIdResponse(String id) {
        Vulnerability vulnerability = vulnerabilityRepository.findByCveId(id)
                .orElseThrow(() -> new NotFoundException("Vulnerability not found with CVE ID: " + id));
        return mapToResponse(vulnerability);
    }

    private VulnerabilityResponse mapToResponse(Vulnerability vulnerability) {
        return VulnerabilityResponse.builder()
            .id(vulnerability.getId())
            .cveId(vulnerability.getCveId())
            .title(vulnerability.getTitle())
            .description(vulnerability.getDescription())
            .riskLevel(vulnerability.getRiskLevel())
            .cvssScore(vulnerability.getCvssScore())
            .cvssVector(vulnerability.getCvssVector())
            .cwe(vulnerability.getCwe())
            .reference(vulnerability.getReference())
            .affectedComponents(vulnerability.getComponents().stream()
                .map(Component::getName)
                .collect(Collectors.toSet()))
            .build();
    }
} 