package com.vulnview.service.impl;

import com.vulnview.dto.vulnerability.ComponentReportDto;
import com.vulnview.dto.vulnerability.VulnerabilityDataDto;
import com.vulnview.dto.vulnerability.VulnerabilityResponse;
import com.vulnview.entity.Component;
import com.vulnview.entity.Vulnerability;
import com.vulnview.entity.RiskLevel;
import com.vulnview.entity.ComponentVulnerability;
import com.vulnview.repository.ComponentRepository;
import com.vulnview.repository.VulnerabilityRepository;
import com.vulnview.repository.ComponentVulnerabilityRepository;
import com.vulnview.repository.SbomRepository;
import com.vulnview.service.VulnerabilityService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.Arrays;
import java.util.Optional;
import java.util.Set;
import java.util.Map;
import java.util.EnumMap;

@Slf4j
@Service
@RequiredArgsConstructor
public class VulnerabilityServiceImpl implements VulnerabilityService {
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ComponentRepository componentRepository;
    private final ComponentVulnerabilityRepository componentVulnerabilityRepository;
    private final SbomRepository sbomRepository;

    @Override
    @Transactional
    public VulnerabilityResponse createVulnerability(Vulnerability vulnerability) {
        log.info("Creating new vulnerability: {}", vulnerability.getCveId());
        Vulnerability savedVulnerability = vulnerabilityRepository.save(vulnerability);
        return mapToResponse(savedVulnerability);
    }

    @Override
    @Transactional
    public VulnerabilityResponse updateVulnerability(Long id, Vulnerability vulnerability) {
        log.info("Updating vulnerability with ID: {}", id);
        Vulnerability existingVulnerability = vulnerabilityRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
        
        existingVulnerability.setTitle(vulnerability.getTitle());
        existingVulnerability.setDescription(vulnerability.getDescription());
        existingVulnerability.setRiskLevel(vulnerability.getRiskLevel());
        existingVulnerability.setCvssScore(vulnerability.getCvssScore());
        existingVulnerability.setCvssVector(vulnerability.getCvssVector());
        existingVulnerability.setCwe(vulnerability.getCwe());
        existingVulnerability.setReference(vulnerability.getReference());
        existingVulnerability.setRemediation(vulnerability.getRemediation());
        existingVulnerability.setRecommendation(vulnerability.getRecommendation());
        existingVulnerability.setSource(vulnerability.getSource());
        existingVulnerability.setScore(vulnerability.getScore());
        existingVulnerability.setSeverity(vulnerability.getSeverity());
        existingVulnerability.setEpssScore(vulnerability.getEpssScore());
        existingVulnerability.setCisaKevDate(vulnerability.getCisaKevDate());
        existingVulnerability.setInCisaKev(vulnerability.isInCisaKev());
        
        Vulnerability updatedVulnerability = vulnerabilityRepository.save(existingVulnerability);
        return mapToResponse(updatedVulnerability);
    }

    @Override
    @Transactional
    public void deleteVulnerability(Long id) {
        log.info("Deleting vulnerability with ID: {}", id);
        vulnerabilityRepository.deleteById(id);
    }

    @Override
    @Transactional
    public VulnerabilityResponse getVulnerabilityById(Long id) {
        log.info("Retrieving vulnerability with ID: {}", id);
        Vulnerability vulnerability = vulnerabilityRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
        return mapToResponse(vulnerability);
    }

    @Override
    public Vulnerability getVulnerabilityByCveId(String cveId) {
        log.info("Retrieving vulnerability with CVE ID: {}", cveId);
        return vulnerabilityRepository.findByCveId(cveId)
                .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
    }

    @Override
    public Page<Vulnerability> getAllVulnerabilities(Pageable pageable) {
        log.info("Retrieving all vulnerabilities with pagination");
        return vulnerabilityRepository.findAll(pageable);
    }

    @Override
    public List<Vulnerability> getVulnerabilitiesByRiskLevel(RiskLevel riskLevel) {
        log.info("Retrieving vulnerabilities with risk level: {}", riskLevel);
        return vulnerabilityRepository.findByRiskLevel(riskLevel);
    }

    @Override
    public List<VulnerabilityResponse> getVulnerabilitiesByRiskLevel(String riskLevel) {
        log.info("Retrieving vulnerabilities with risk level: {}", riskLevel);
        try {
            RiskLevel level;
            try {
                level = RiskLevel.valueOf(riskLevel.toUpperCase());
            } catch (IllegalArgumentException e) {
                // Try lowercase mapping for compatibility
                level = RiskLevel.valueOf(riskLevel.toLowerCase());
            }
            return vulnerabilityRepository.findByRiskLevel(level)
                    .stream()
                    .map(this::mapToResponse)
                    .collect(Collectors.toList());
        } catch (IllegalArgumentException e) {
            log.error("Invalid risk level: {}", riskLevel);
            throw new IllegalArgumentException("Invalid risk level: " + riskLevel + ". Valid values are: " + 
                Arrays.toString(RiskLevel.values()));
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<ComponentReportDto> getVulnerabilityByComponentPurl(List<String> purls) {
        log.info("Getting vulnerabilities for components with PURLs: {}", purls);
        return purls.stream()
            .map(purl -> {
                Component component = componentRepository.findByPackageUrl(purl)
                    .orElseThrow(() -> new RuntimeException("Component not found with PURL: " + purl));
                
                List<Vulnerability> vulnerabilities = component.getComponentVulnerabilities().stream()
                    .map(ComponentVulnerability::getVulnerability)
                    .collect(Collectors.toList());

                ComponentReportDto report = new ComponentReportDto();
                report.setComponentName(component.getName());
                report.setComponentVersion(component.getVersion());
                report.setPackageUrl(purl);
                report.setVulnerabilities(vulnerabilities.stream()
                    .map(this::mapToResponse)
                    .collect(Collectors.toList()));
                return report;
            })
            .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void saveVulnerabilityReport(List<ComponentReportDto> componentReports) {
        log.info("Saving vulnerability report for {} components", componentReports.size());
        componentReports.forEach(report -> {
            Component component = componentRepository.findByPackageUrl(report.getPackageUrl())
                .orElseThrow(() -> new RuntimeException("Component not found with PURL: " + report.getPackageUrl()));

            report.getVulnerabilities().forEach(vulnResponse -> {
                Vulnerability vulnerability = vulnerabilityRepository.findByCveId(vulnResponse.getCveId())
                    .orElseGet(() -> {
                        Vulnerability newVuln = new Vulnerability();
                        newVuln.setCveId(vulnResponse.getCveId());
                        newVuln.setTitle(vulnResponse.getTitle());
                        newVuln.setDescription(vulnResponse.getDescription());
                        newVuln.setRiskLevel(vulnResponse.getRiskLevel());
                        newVuln.setCvssScore(vulnResponse.getCvssScore());
                        newVuln.setCvssVector(vulnResponse.getCvssVector());
                        newVuln.setCwe(vulnResponse.getCwe());
                        newVuln.setReference(vulnResponse.getReference());
                        newVuln.setRemediation(vulnResponse.getRemediation());
                        newVuln.setRecommendation(vulnResponse.getRecommendation());
                        return vulnerabilityRepository.save(newVuln);
                    });

                ComponentVulnerability cv = new ComponentVulnerability();
                cv.setComponent(component);
                cv.setVulnerability(vulnerability);
                componentVulnerabilityRepository.save(cv);
            });
        });
    }

    @Override
    @Transactional(readOnly = true)
    public List<VulnerabilityResponse> getAllVulnerabilitiesResponse() {
        log.info("Getting all vulnerabilities as response DTOs");
        return vulnerabilityRepository.findAll().stream()
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public VulnerabilityResponse getVulnerabilityByIdResponse(String id) {
        log.info("Getting vulnerability with id: {} as response DTO", id);
        Vulnerability vulnerability = vulnerabilityRepository.findById(Long.parseLong(id))
            .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
        return mapToResponse(vulnerability);
    }

    @Override
    @Transactional
    public void addComponentToVulnerability(Long vulnerabilityId, Long componentId, Long sbomId) {
        log.info("Adding component {} to vulnerability {} in SBOM {}", componentId, vulnerabilityId, sbomId);
        Vulnerability vulnerability = vulnerabilityRepository.findById(vulnerabilityId)
            .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
        Component component = componentRepository.findById(componentId)
            .orElseThrow(() -> new RuntimeException("Component not found"));
        com.vulnview.entity.Sbom sbom = sbomRepository.findById(sbomId)
            .orElseThrow(() -> new RuntimeException("SBOM not found"));

        vulnerability.addComponent(component, sbom);
        vulnerabilityRepository.save(vulnerability);
    }

    @Override
    @Transactional
    public void removeComponentFromVulnerability(Long vulnerabilityId, Long componentId) {
        log.info("Removing component {} from vulnerability {}", componentId, vulnerabilityId);
        Vulnerability vulnerability = vulnerabilityRepository.findById(vulnerabilityId)
            .orElseThrow(() -> new RuntimeException("Vulnerability not found"));
        Component component = componentRepository.findById(componentId)
            .orElseThrow(() -> new RuntimeException("Component not found"));

        vulnerability.removeComponent(component);
        vulnerabilityRepository.save(vulnerability);
    }

    @Override
    @Transactional(readOnly = true)
    public List<VulnerabilityResponse> compareVulnerabilities(List<String> cveIds) {
        log.info("Comparing vulnerabilities with CVE IDs: {}", cveIds);
        return cveIds.stream()
            .map(cveId -> vulnerabilityRepository.findByCveId(cveId)
                .map(this::mapToResponse)
                .orElse(null))
            .filter(response -> response != null)
            .collect(Collectors.toList());
    }

    @Override
    public List<VulnerabilityResponse> getVulnerabilitiesByComponentAndRiskLevel(String componentPurl, RiskLevel riskLevel) {
        log.info("Getting vulnerabilities with risk level {} for component: {}", riskLevel, componentPurl);
        Component component = componentRepository.findByPackageUrl(componentPurl)
            .orElseThrow(() -> new RuntimeException("Component not found"));
        
        return component.getComponentVulnerabilities().stream()
            .map(ComponentVulnerability::getVulnerability)
            .filter(vuln -> vuln.getRiskLevel() == riskLevel)
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    @Override
    public List<VulnerabilityResponse> getVulnerabilitiesByProjectAndRiskLevel(Long projectId, RiskLevel riskLevel) {
        log.info("Getting vulnerabilities with risk level {} for project: {}", riskLevel, projectId);
        return vulnerabilityRepository.findByProjectIdAndRiskLevel(projectId, riskLevel).stream()
            .map(this::mapToResponse)
            .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public Vulnerability findOrCreateGlobalVulnerability(VulnerabilityDataDto vulnerabilityData, String source) {
        log.info("Finding or creating global vulnerability for CVE: {}", vulnerabilityData.getCveId());
        
        Optional<Vulnerability> existingVulnerability = vulnerabilityRepository.findByCveId(vulnerabilityData.getCveId())
            .stream()
            .findFirst();
            
        if (existingVulnerability.isPresent()) {
            log.info("Found existing vulnerability for CVE: {}", vulnerabilityData.getCveId());
            return existingVulnerability.get();
        }

        Vulnerability vulnerability = new Vulnerability();
        updateVulnerabilityFromDto(vulnerability, vulnerabilityData);
        vulnerability.setSource(source);
        
        Vulnerability savedVulnerability = vulnerabilityRepository.save(vulnerability);
        log.info("Created new vulnerability for CVE: {}", savedVulnerability.getCveId());
        return savedVulnerability;
    }

    @Override
    @Transactional
    public void linkComponentToVulnerability(Long componentId, Long vulnerabilityId, String details) {
        log.info("Linking component {} to vulnerability {}", componentId, vulnerabilityId);
        
        Component component = componentRepository.findById(componentId)
            .orElseThrow(() -> new RuntimeException("Component not found"));
        Vulnerability vulnerability = vulnerabilityRepository.findById(vulnerabilityId)
            .orElseThrow(() -> new RuntimeException("Vulnerability not found"));

        // Check if link already exists
        boolean linkExists = component.getComponentVulnerabilities().stream()
            .anyMatch(cv -> cv.getVulnerability().getId().equals(vulnerabilityId));

        if (!linkExists) {
            ComponentVulnerability cv = new ComponentVulnerability();
            cv.setComponent(component);
            cv.setVulnerability(vulnerability);
            cv.setDescription(details);
            componentVulnerabilityRepository.save(cv);
            
            // Update both sides of the relationship
            component.getComponentVulnerabilities().add(cv);
            
            componentRepository.save(component);
            vulnerabilityRepository.save(vulnerability);
        }
    }

    @Override
    public Set<Component> getComponents() {
        return vulnerabilityRepository.findAll().stream()
            .flatMap(v -> v.getComponentVulnerabilities().stream())
            .map(ComponentVulnerability::getComponent)
            .collect(Collectors.toSet());
    }

    @Override
    public Map<RiskLevel, Integer> getVulnerabilitySummaryByProject(Long projectId) {
        log.info("Getting vulnerability summary for project: {}", projectId);
        Map<RiskLevel, Integer> summary = new EnumMap<>(RiskLevel.class);
        
        // Initialize all risk levels with 0
        for (RiskLevel level : RiskLevel.values()) {
            summary.put(level, 0);
        }
        
        // Get all vulnerabilities for the project and count by risk level
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findByProjectId(projectId);
        for (Vulnerability vuln : vulnerabilities) {
            RiskLevel level = vuln.getRiskLevel();
            summary.put(level, summary.get(level) + 1);
        }
        
        return summary;
    }

    @Override
    public List<VulnerabilityResponse> getVulnerabilitiesWithRiskLevelNotNone() {
        log.info("Retrieving vulnerabilities with risk level != NONE");
        return vulnerabilityRepository.findByRiskLevelNotNone()
                .stream()
                .map(this::mapToResponse)
                .collect(Collectors.toList());
    }

    private void updateVulnerabilityFromDto(Vulnerability vulnerability, VulnerabilityDataDto dto) {
        vulnerability.setCveId(dto.getCveId());
        vulnerability.setTitle(dto.getTitle());
        vulnerability.setDescription(dto.getDescription());
        vulnerability.setCvssScore(dto.getCvssScore());
        vulnerability.setCwe(dto.getCwe());
        vulnerability.setReference(dto.getReference());
        vulnerability.setRiskLevel(dto.getRiskLevel());
    }

    private VulnerabilityResponse mapToResponse(Vulnerability vulnerability) {
        return VulnerabilityResponse.builder()
            .id(vulnerability.getId())
            .cveId(vulnerability.getCveId())
            .title(vulnerability.getTitle())
            .description(vulnerability.getDescription())
            .riskLevel(vulnerability.getRiskLevel())
            .cvssScore(vulnerability.getCvssScore())
            .cvssVector(vulnerability.getCvssVector())
            .cwe(vulnerability.getCwe())
            .reference(vulnerability.getReference())
            .affectedComponents(vulnerability.getComponentVulnerabilities().stream()
                .map(cv -> cv.getComponent().getPackageUrl())
                .collect(Collectors.toSet()))
            .publishedDate(vulnerability.getPublishedDate())
            .lastModifiedDate(vulnerability.getLastModifiedDate())
            .createdAt(vulnerability.getCreatedAt())
            .updatedAt(vulnerability.getUpdatedAt())
            .remediation(vulnerability.getRemediation())
            .recommendation(vulnerability.getRecommendation())
            .source(vulnerability.getSource())
            .score(vulnerability.getScore())
            .severity(vulnerability.getSeverity())
            .epssScore(vulnerability.getEpssScore())
            .cisaKevDate(vulnerability.getCisaKevDate())
            .inCisaKev(vulnerability.isInCisaKev())
            .build();
    }
} 