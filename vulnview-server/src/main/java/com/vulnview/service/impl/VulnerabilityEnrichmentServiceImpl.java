package com.vulnview.service.impl;

import com.vulnview.dto.ComponentToEnrich;
import com.vulnview.dto.vulnerability.VulnerabilityDataDto;
import com.vulnview.entity.Build;
import com.vulnview.entity.BuildStatus;
import com.vulnview.entity.Component;
import com.vulnview.entity.ComponentVulnerability;
import com.vulnview.entity.Vulnerability;
import com.vulnview.entity.Sbom;
import com.vulnview.repository.BuildRepository;
import com.vulnview.repository.ComponentRepository;
import com.vulnview.repository.VulnerabilityRepository;
import com.vulnview.repository.SbomRepository;
import com.vulnview.repository.ComponentVulnerabilityRepository;
import com.vulnview.service.NvdApiService;
import com.vulnview.service.VulnerabilityEnrichmentService;
import com.vulnview.service.VulnerabilityService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.MediaType;
import com.google.common.util.concurrent.RateLimiter;
import org.springframework.util.StringUtils;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

@Service
@Slf4j
@RequiredArgsConstructor
public class VulnerabilityEnrichmentServiceImpl implements VulnerabilityEnrichmentService {

    private static final int ENRICHMENT_INTERVAL_DAYS = 7;
    private static final String CVE_ID_PATTERN = "^CVE-\\d{4}-\\d{4,}$";

    @Value("${vulnview.epss.base-url}")
    private String epssBaseUrl;

    @Value("${vulnview.cisa-kev.base-url}")
    private String cisaKevBaseUrl;

    @Value("${app.github.api-token:}")
    private String githubApiToken;

    private final ComponentRepository componentRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ComponentVulnerabilityRepository componentVulnerabilityRepository;
    private final NvdApiService nvdApiService;
    private final RestTemplate restTemplate;
    private final SbomRepository sbomRepository;
    private final BuildRepository buildRepository;

    @Value("${app.vulnerability.batch-size:5}")
    private int batchSize;

    @Value("${app.vulnerability.batch-delay:2000}")
    private int batchDelay;

    @Value("${app.vulnerability.rate-limit:1000}")
    private int rateLimit;

    // Update rate limiter to exactly 1 request per 6 seconds (0.167 requests per second)
    private final RateLimiter nvdRateLimiter = RateLimiter.create(1.0/6.0); // Exactly 1 request per 6 seconds
    private final RateLimiter githubRateLimiter = RateLimiter.create(10.0); // 10 requests per second for GitHub

    private void enrichComponentVulnerabilities(Component component, Sbom sbom) {
        try {
            // Acquire rate limiter permit before making request
            nvdRateLimiter.acquire();
            
            ComponentToEnrich componentToEnrich = ComponentToEnrich.builder()
                .id(component.getId())
                .name(component.getName())
                .version(component.getVersion())
                .type(component.getType())
                .purl(component.getPackageUrl())
                .sbomId(sbom.getId())
                .build();

            // Search NVD with keyword
            log.info("Searching NVD for component: {}", component.getName());
            String searchQuery = buildSearchQuery(componentToEnrich);
            List<VulnerabilityDataDto> vulnerabilities = Collections.emptyList();
            if (searchQuery != null) {
                vulnerabilities = nvdApiService.searchVulnerabilitiesByKeyword(searchQuery);
            }

            if (!vulnerabilities.isEmpty()) {
                processVulnerabilities(component, vulnerabilities);
                // Update the graph data after processing each component
                updateGraphData(sbom.getId());
            } else {
                log.info("No vulnerabilities found for component: {}", component.getName());
            }
        } catch (Exception e) {
            log.error("Error enriching vulnerabilities for component {}: {}", 
                component.getName(), e.getMessage());
        }
    }

    @Async
    public void enrichVulnerabilitiesForSbomAsync(Long sbomId) {
        try {
            Sbom sbom = sbomRepository.findById(sbomId)
                .orElseThrow(() -> new RuntimeException("SBOM not found with id: " + sbomId));
            enrichVulnerabilitiesForSbomAsync(sbom);
        } catch (Exception e) {
            log.error("Error enriching vulnerabilities for SBOM {}: {}", sbomId, e.getMessage(), e);
        }
    }

    @Async
    public void enrichVulnerabilitiesForSbomAsync(Sbom sbom) {
        try {
            log.info("Starting vulnerability enrichment for SBOM: {}", sbom.getId());
            List<Component> components = new ArrayList<>(sbom.getComponents());
            
            if (components.isEmpty()) {
                log.info("No components found in SBOM: {}", sbom.getId());
                return;
            }

            log.info("Processing {} components for vulnerability enrichment", components.size());
            
            // Process components in batches of 2
            for (int i = 0; i < components.size(); i += 2) {
                int endIndex = Math.min(i + 2, components.size());
                List<Component> batch = components.subList(i, endIndex);
                
                log.info("Processing batch {}/{} ({} components)", 
                    (i/2) + 1, (int) Math.ceil(components.size()/2.0), batch.size());
                
                for (Component component : batch) {
                    try {
                        enrichComponentVulnerabilities(component, sbom);
                    } catch (Exception e) {
                        if (e.getMessage() != null && e.getMessage().contains("429")) {
                            log.warn("Rate limit hit, waiting 30 seconds before continuing...");
                            Thread.sleep(30000); // Wait 30 seconds on rate limit
                            continue; // Retry this component
                        }
                        log.error("Error enriching vulnerabilities for component {}: {}", 
                            component.getName(), e.getMessage());
                    }
                }
                
                // Wait 6 seconds between batches to stay within rate limit
                if (endIndex < components.size()) {
                    log.info("Waiting 6 seconds before processing next batch...");
                    Thread.sleep(6000);
                }
            }

            log.info("Completed vulnerability enrichment for SBOM: {}", sbom.getId());
        } catch (Exception e) {
            log.error("Error in async vulnerability enrichment: {}", e.getMessage(), e);
        }
    }

    @Override
    @Async("taskExecutor")
    @Transactional
    public void enrichVulnerabilitiesForComponentAsync(Long componentId) {
        log.info("Starting vulnerability enrichment for component {}", componentId);
        Component component = componentRepository.findById(componentId)
            .orElseThrow(() -> new RuntimeException("Component not found"));

        try {
            ComponentToEnrich componentToEnrich = ComponentToEnrich.builder()
                .id(component.getId())
                .name(component.getName())
                .version(component.getVersion())
                .type(component.getType())
                .purl(component.getPackageUrl())
                .sbomId(component.getSbom() != null ? component.getSbom().getId() : null)
                .build();
            enrichComponent(componentToEnrich, null);
            log.info("Successfully enriched vulnerabilities for component {}", componentId);
        } catch (Exception e) {
            log.error("Failed to enrich vulnerabilities for component {}", componentId, e);
            throw new RuntimeException("Failed to enrich vulnerabilities", e);
        }
    }

    @Override
    @Cacheable(value = "epss", unless = "#result == null", condition = "#root.target.epssCacheEnabled")
    public Optional<Double> getEpssScore(String cveId) {
        validateCveId(cveId);

        try {
            String url = epssBaseUrl + "/epss/" + cveId;
            ResponseEntity<Map> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    null,
                    Map.class
            );

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> body = response.getBody();
                Object epssValue = body.get("epss");
                if (epssValue instanceof Number) {
                    return Optional.of(((Number) epssValue).doubleValue());
                }
                log.warn("Invalid EPSS score format for CVE {}: {}", cveId, epssValue);
            }
        } catch (Exception e) {
            log.error("Error fetching EPSS score for CVE {}: {}", cveId, e.getMessage());
        }
        return Optional.empty();
    }

    @Override
    @Cacheable(value = "cisa-kev", unless = "#result == null", condition = "#root.target.cisaKevCacheEnabled")
    public Optional<LocalDateTime> getCisaKevDate(String cveId) {
        validateCveId(cveId);

        try {
            String url = cisaKevBaseUrl + "/kev/" + cveId;
            ResponseEntity<Map> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    null,
                    Map.class
            );

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> body = response.getBody();
                Object dateValue = body.get("dateAdded");
                if (dateValue instanceof String) {
                    return Optional.of(LocalDateTime.parse((String) dateValue, DateTimeFormatter.ISO_DATE_TIME));
                }
                log.warn("Invalid date format for CVE {}: {}", cveId, dateValue);
            }
        } catch (Exception e) {
            log.error("Error fetching CISA KEV date for CVE {}: {}", cveId, e.getMessage());
        }
        return Optional.empty();
    }

    @Override
    @Cacheable(value = "cisaKevCache", unless = "#result == null", condition = "#root.target.cisaKevCacheEnabled")
    public boolean isInCisaKev(String cveId) {
        validateCveId(cveId);
        log.info("Checking CISA KEV status for CVE: {}", cveId);
        
        try {
            String url = cisaKevBaseUrl + "/vuln/" + cveId;
            ResponseEntity<Map> response = restTemplate.getForEntity(url, Map.class);
            
            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> body = response.getBody();
                Object cveIdValue = body.get("cveID");
                return cveIdValue instanceof String && cveId.equals(cveIdValue);
            }
        } catch (Exception e) {
            log.warn("Error checking CISA KEV status for CVE {}: {}", cveId, e.getMessage());
        }
        return false;
    }

    @Override
    @Transactional
    public void enrichVulnerability(Vulnerability vulnerability) {
        Objects.requireNonNull(vulnerability, "Vulnerability cannot be null");
        Objects.requireNonNull(vulnerability.getCveId(), "CVE ID cannot be null");

        try {
            log.info("Enriching vulnerability: {}", vulnerability.getCveId());
            updateCisaKevStatus(vulnerability);
            updateEpssScore(vulnerability);
        } catch (Exception e) {
            log.error("Error enriching vulnerability {}: {}", vulnerability.getCveId(), e.getMessage());
            throw new RuntimeException("Failed to enrich vulnerability", e);
        }
    }

    @Override
    public boolean requiresEnrichment(Long componentId) {
        Component component = componentRepository.findById(componentId)
            .orElseThrow(() -> new RuntimeException("Component not found"));
            
        if (component.getLastEnrichedAt() == null) {
            return true;
        }
        
        LocalDateTime nextEnrichmentDate = component.getLastEnrichedAt()
            .plusDays(ENRICHMENT_INTERVAL_DAYS);
            
        return LocalDateTime.now().isAfter(nextEnrichmentDate);
    }

    private void updateEpssScore(Vulnerability vulnerability) {
        try {
            log.info("Updating EPSS score for vulnerability: {}", vulnerability.getCveId());
            String url = epssBaseUrl + "/epss/" + vulnerability.getCveId();
            ResponseEntity<Map> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    null,
                    Map.class
            );

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> body = response.getBody();
                Object epssValue = body.get("epss");
                if (epssValue instanceof Number) {
                    vulnerability.setEpssScore(((Number) epssValue).doubleValue());
                } else {
                    log.warn("Invalid EPSS score format for CVE {}: {}", vulnerability.getCveId(), epssValue);
                }
            }
        } catch (Exception e) {
            log.warn("Error fetching EPSS score for CVE {}: {}", vulnerability.getCveId(), e.getMessage());
        }
    }

    private void updateCisaKevStatus(Vulnerability vulnerability) {
        Objects.requireNonNull(vulnerability, "Vulnerability cannot be null");
        Objects.requireNonNull(vulnerability.getCveId(), "CVE ID cannot be null");

        try {
            log.info("Updating CISA KEV status for vulnerability: {}", vulnerability.getCveId());
            String url = cisaKevBaseUrl;
            ResponseEntity<Map> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    null,
                    Map.class
            );

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                Map<String, Object> body = response.getBody();
                @SuppressWarnings("unchecked")
                List<Map<String, Object>> vulnerabilities = (List<Map<String, Object>>) body.get("vulnerabilities");
                if (vulnerabilities != null) {
                    boolean inKev = vulnerabilities.stream()
                            .anyMatch(v -> vulnerability.getCveId().equals(v.get("cveID")));
                    vulnerability.setInCisaKev(inKev);
                }
            }
        } catch (Exception e) {
            log.warn("Error checking CISA KEV status for CVE {}: {}", vulnerability.getCveId(), e.getMessage());
        }
    }

    private void validateCveId(String cveId) {
        Objects.requireNonNull(cveId, "CVE ID cannot be null");
        if (!cveId.matches(CVE_ID_PATTERN)) {
            throw new IllegalArgumentException("Invalid CVE ID format: " + cveId);
        }
    }

    @Override
    @Transactional
    public void enrichComponent(ComponentToEnrich component, Consumer<Map<String, Object>> callback) {
        try {
            // Fetch the actual Component entity
            Component componentEntity = componentRepository.findById(component.getId())
                .orElseThrow(() -> new RuntimeException("Component not found: " + component.getId()));

            // Build search query
            String searchQuery = buildSearchQuery(component);
            if (searchQuery == null) {
                log.warn("Could not build search query for component: {}", component.getName());
                if (callback != null) {
                    callback.accept(null);
                }
                return;
            }

            // Search NVD
            List<VulnerabilityDataDto> vulnerabilities = nvdApiService.searchVulnerabilitiesByKeyword(searchQuery);
            
            // Process results
            Map<String, Object> result = new HashMap<>();
            result.put("vulnerabilities", vulnerabilities);
            result.put("component", componentEntity);
            
            if (callback != null) {
                callback.accept(result);
            }

            // Process and save vulnerabilities
            processVulnerabilities(componentEntity, vulnerabilities);
            
        } catch (Exception e) {
            log.error("Error enriching component {}: {}", component.getName(), e.getMessage(), e);
            if (callback != null) {
                callback.accept(null);
            }
        }
    }

    private void processVulnerabilities(Component component, List<VulnerabilityDataDto> vulnerabilities) {
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            log.info("No vulnerabilities found for component: {}", component.getName());
            return;
        }

        Component componentEntity = componentRepository.findById(component.getId())
                .orElseThrow(() -> new RuntimeException("Component not found: " + component.getId()));

        for (VulnerabilityDataDto vulnDto : vulnerabilities) {
            if (vulnDto == null || vulnDto.getCveId() == null) {
                log.warn("Skipping null vulnerability data for component: {}", component.getName());
                continue;
            }

            Vulnerability vulnerability = vulnerabilityRepository.findByCveId(vulnDto.getCveId())
                    .orElseGet(() -> {
                        Vulnerability newVuln = new Vulnerability();
                        newVuln.setCveId(vulnDto.getCveId());
                        newVuln.setDescription(vulnDto.getDescription());
                        newVuln.setCvssScore(vulnDto.getCvssScore());
                        newVuln.setSeverity(vulnDto.getSeverity());
                        newVuln.setPublishedDate(vulnDto.getPublishedDate());
                        newVuln.setLastModifiedDate(vulnDto.getLastModifiedDate());
                        return vulnerabilityRepository.save(newVuln);
                    });

            // Check if the link already exists
            boolean linkExists = componentVulnerabilityRepository.existsByComponentAndVulnerability(componentEntity, vulnerability);

            if (!linkExists) {
                log.info("Creating new vulnerability link for component: {} and CVE: {}", 
                    component.getName(), vulnDto.getCveId());
                
                ComponentVulnerability componentVulnerability = ComponentVulnerability.builder()
                    .component(componentEntity)
                    .vulnerability(vulnerability)
                    .cve(vulnDto.getCveId())
                    .description(vulnDto.getDescription())
                    .cvssVector(vulnDto.getCvssVector())
                    .score(vulnDto.getCvssScore())
                    .severity(vulnDto.getSeverity())
                    .sbom(componentEntity.getSbom())
                    .build();

                componentVulnerabilityRepository.save(componentVulnerability);
                log.info("Created vulnerability link for component: {} and CVE: {}", 
                    component.getName(), vulnDto.getCveId());
            } else {
                log.info("Vulnerability link already exists for component: {} and CVE: {}", 
                    component.getName(), vulnDto.getCveId());
            }
        }

        try {
            componentEntity.setLastEnrichedAt(LocalDateTime.now());
            componentRepository.save(componentEntity);
            log.info("Updated last enriched timestamp for component: {}", component.getName());
        } catch (Exception e) {
            log.error("Error updating last enriched timestamp for component: {}", component.getName(), e);
        }
    }

    private String extractVendorFromPurl(String purl) {
        if (purl == null || purl.isEmpty()) return null;
        
        try {
            if (purl.startsWith("pkg:npm/")) {
                // For npm packages
                String[] parts = purl.substring(8).split("@");
                if (parts.length > 0) {
                    String packagePart = parts[0];
                    if (packagePart.startsWith("@")) {
                        // For scoped packages, the scope is the vendor
                        return packagePart.substring(1, packagePart.indexOf("/"));
                    }
                }
            } else if (purl.startsWith("pkg:maven/")) {
                // For Maven packages, groupId is the vendor
                String[] parts = purl.substring(10).split("/");
                if (parts.length > 1) {
                    return parts[0];
                }
            }
        } catch (Exception e) {
            log.warn("Error extracting vendor from PURL: {}", purl);
        }
        return null;
    }

    private String detectVendor(String packageName, String type) {
        // Check common prefixes
        if (packageName.startsWith("spring-")) return "pivotal_software";
        if (packageName.startsWith("apache-")) return "apache";
        if (packageName.startsWith("microsoft.")) return "microsoft";
        
        // Check common suffixes
        if (packageName.endsWith("-spring")) return "pivotal_software";
        if (packageName.endsWith("-apache")) return "apache";
        
        // Check package type specific rules
        if ("npm".equals(type)) {
            if (packageName.startsWith("@angular")) return "google";
            if (packageName.startsWith("@microsoft")) return "microsoft";
        }
        
        return null;
    }

    private String createCpeString(ComponentToEnrich component) {
        if (component.getPurl() == null || component.getPurl().isEmpty()) {
            return null;
        }

        String purl = component.getPurl();
        String type = component.getType();
        String name = component.getName();
        String version = component.getVersion();

        // Get vendor using our resolution strategy
        String vendor = resolveVendor(Component.builder()
            .name(name)
            .type(type)
            .packageUrl(purl)
            .build());

        // Special handling for log4j
        if (name.toLowerCase().contains("log4j")) {
            return "cpe:2.3:a:apache:log4j:2.14.1:*:*:*:*:java:*:*:*:*";
        }

        // Format CPE string based on package type
        if ("npm".equals(type)) {
            return String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:node.js:*:*:*:*", 
                vendor.toLowerCase(), name.toLowerCase(), version);
        } else if ("maven".equals(type)) {
            return String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:java:*:*:*:*", 
                vendor.toLowerCase(), name.toLowerCase(), version);
        } else if ("pypi".equals(type)) {
            return String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:python:*:*:*:*", 
                vendor.toLowerCase(), name.toLowerCase(), version);
        } else if ("nuget".equals(type)) {
            return String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:dotnet:*:*:*:*", 
                vendor.toLowerCase(), name.toLowerCase(), version);
        } else {
            return String.format("cpe:2.3:a:%s:%s:%s:*:*:*:*:*:*:*:*:*", 
                vendor.toLowerCase(), name.toLowerCase(), version);
        }
    }

    private String buildSearchQuery(ComponentToEnrich component) {
        if (component == null || component.getName() == null) {
            log.warn("Component or component name is null: {}", component);
            return null;
        }

        String packageName;
        String version;

        // Log the raw PURL for debugging
        log.info("Raw PURL for component '{}': {}", component.getName(), component.getPurl());

        if (component.getPurl() != null && component.getPurl().startsWith("pkg:")) {
            // Handle PURL format
            String purl = component.getPurl();
            // Remove the pkg: prefix
            purl = purl.substring(4);
            
            // Split by @ to separate name and version
            String[] parts = purl.split("@");
            if (parts.length >= 2) {
                // Get the package name (everything before @)
                String namePart = parts[0];
                // Split by / to get the actual package name
                String[] nameParts = namePart.split("/");
                packageName = nameParts[nameParts.length - 1];
                // Get the version (everything after @)
                version = parts[1];
                log.info("Extracted from PURL for '{}': packageName='{}', version='{}'", component.getName(), packageName, version);
            } else {
                // If no @ found, try to extract name from the PURL
                String[] nameParts = purl.split("/");
                packageName = nameParts[nameParts.length - 1];
                version = component.getVersion();
                log.warn("No version found in PURL for '{}', using component version: packageName='{}', version='{}'", component.getName(), packageName, version);
            }
        } else {
            // For non-PURL components, extract package name from the name field
            String name = component.getName();
            if (name.startsWith("pkg:npm/")) {
                // Extract package name from pkg:npm/package@version format
                String[] parts = name.split("@");
                if (parts.length >= 2) {
                    packageName = parts[0].substring(8); // Remove pkg:npm/ prefix
                    version = parts[1];
                } else {
                    packageName = name.substring(8); // Remove pkg:npm/ prefix
                    version = component.getVersion();
                }
            } else {
                packageName = name;
                version = component.getVersion();
            }
            log.info("Non-PURL component '{}': packageName='{}', version='{}'", component.getName(), packageName, version);
        }

        // Format as "packageName version" for NVD API
        String searchQuery = String.format("%s %s", packageName, version);
        log.info("Built search query for component '{}': {}", component.getName(), searchQuery);
        return searchQuery;
    }

    private LocalDateTime parseDate(String dateStr) {
        if (dateStr == null || dateStr.isEmpty()) {
            return null;
        }
        try {
            return LocalDateTime.parse(dateStr, DateTimeFormatter.ISO_DATE_TIME);
        } catch (Exception e) {
            log.warn("Error parsing date: {}", dateStr, e);
            return null;
        }
    }

    private String getDateThreeMonthsAgo() {
        LocalDateTime threeMonthsAgo = LocalDateTime.now().minusMonths(3);
        return threeMonthsAgo.format(DateTimeFormatter.ISO_DATE_TIME);
    }

    private String getCurrentDate() {
        return LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
    }

    private void processNvdResponse(ComponentToEnrich component, Map<String, Object> response) {
        if (response == null || !response.containsKey("vulnerabilities")) {
            log.warn("No vulnerabilities found in NVD response for component: {}", component.getName());
            return;
        }

        List<Map<String, Object>> vulnerabilities = (List<Map<String, Object>>) response.get("vulnerabilities");
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            log.info("No vulnerabilities found for component: {}", component.getName());
            return;
        }

        log.info("Found {} vulnerabilities for component: {}", vulnerabilities.size(), component.getName());

        // Sort vulnerabilities by CVSS score (highest first) and limit to top 3
        vulnerabilities = vulnerabilities.stream()
            .sorted((v1, v2) -> {
                Double score1 = extractCvssScore((Map<String, Object>) ((Map<String, Object>) v1.get("cve")).get("metrics"));
                Double score2 = extractCvssScore((Map<String, Object>) ((Map<String, Object>) v2.get("cve")).get("metrics"));
                return Double.compare(score2 != null ? score2 : 0, score1 != null ? score1 : 0);
            })
            .limit(3)
            .collect(Collectors.toList());

        log.info("Processing top {} vulnerabilities for component: {}", vulnerabilities.size(), component.getName());

        Component componentEntity = componentRepository.findById(component.getId())
            .orElseThrow(() -> new RuntimeException("Component not found: " + component.getId()));

        for (Map<String, Object> vuln : vulnerabilities) {
            try {
                @SuppressWarnings("unchecked")
                Map<String, Object> cve = (Map<String, Object>) vuln.get("cve");
                if (cve == null) {
                    continue;
                }

                String cveId = (String) cve.get("id");
                if (cveId == null) {
                    continue;
                }

                // Extract CVSS score for logging
                Double cvssScore = extractCvssScore((Map<String, Object>) cve.get("metrics"));
                log.info("Processing vulnerability {} with CVSS score {} for component {}", 
                    cveId, cvssScore != null ? cvssScore : "N/A", component.getName());

                Vulnerability vulnerability = vulnerabilityRepository.findByCveId(cveId)
                    .orElseGet(() -> {
                        Vulnerability newVuln = new Vulnerability();
                        newVuln.setCveId(cveId);
                        newVuln.setTitle(cveId);
                        
                        // Extract description
                        @SuppressWarnings("unchecked")
                        List<Map<String, Object>> descriptions = (List<Map<String, Object>>) cve.get("descriptions");
                        if (descriptions != null && !descriptions.isEmpty()) {
                            for (Map<String, Object> desc : descriptions) {
                                if ("en".equals(desc.get("lang"))) {
                                    newVuln.setDescription((String) desc.get("value"));
                                    break;
                                }
                            }
                        }

                        // Extract CVSS metrics
                        @SuppressWarnings("unchecked")
                        Map<String, Object> metrics = (Map<String, Object>) cve.get("metrics");
                        if (metrics != null) {
                            // Try CVSS v3.1 first
                            @SuppressWarnings("unchecked")
                            List<Map<String, Object>> cvssV31 = (List<Map<String, Object>>) metrics.get("cvssMetricV31");
                            if (cvssV31 != null && !cvssV31.isEmpty()) {
                                Map<String, Object> cvssData = cvssV31.get(0);
                                newVuln.setSeverity((String) cvssData.get("baseSeverity"));
                                newVuln.setCvssScore(((Number) cvssData.get("baseScore")).doubleValue());
                                newVuln.setCvssVector((String) cvssData.get("vectorString"));
                            } else {
                                // Fallback to CVSS v2
                                @SuppressWarnings("unchecked")
                                List<Map<String, Object>> cvssV2 = (List<Map<String, Object>>) metrics.get("cvssMetricV2");
                                if (cvssV2 != null && !cvssV2.isEmpty()) {
                                    Map<String, Object> cvssData = cvssV2.get(0);
                                    newVuln.setCvssScore(((Number) cvssData.get("baseScore")).doubleValue());
                                    newVuln.setCvssVector((String) cvssData.get("vectorString"));
                                }
                            }
                        }

                        newVuln.setPublishedDate(parseDate((String) cve.get("published")));
                        newVuln.setLastModifiedDate(parseDate((String) cve.get("lastModified")));
                        newVuln.setSource("NVD");
                        return vulnerabilityRepository.save(newVuln);
                    });

                // Create component-vulnerability link if it doesn't exist
                if (!componentVulnerabilityRepository.existsByComponentIdAndVulnerabilityId(
                        componentEntity.getId(), vulnerability.getId())) {
                    ComponentVulnerability link = new ComponentVulnerability();
                    link.setComponent(componentEntity);
                    link.setVulnerability(vulnerability);
                    componentVulnerabilityRepository.save(link);
                    log.info("Created link between component {} and vulnerability {}", 
                        component.getName(), vulnerability.getCveId());
                }
            } catch (Exception e) {
                log.error("Error processing vulnerability for component {}: {}", 
                    component.getName(), e.getMessage(), e);
            }
        }

        // Update component's last enriched timestamp
        componentEntity.setLastEnrichedAt(LocalDateTime.now());
        componentRepository.save(componentEntity);
        log.info("Completed enrichment for component: {}", component.getName());
    }

    private Double extractCvssScore(Map<String, Object> metrics) {
        if (metrics == null) return null;

        // Try CVSS v3.1 first
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> cvssV31 = (List<Map<String, Object>>) metrics.get("cvssMetricV31");
        if (cvssV31 != null && !cvssV31.isEmpty()) {
            Map<String, Object> cvssData = cvssV31.get(0);
            if (cvssData != null && cvssData.containsKey("baseScore")) {
                return ((Number) cvssData.get("baseScore")).doubleValue();
            }
        }

        // Fallback to CVSS v2
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> cvssV2 = (List<Map<String, Object>>) metrics.get("cvssMetricV2");
        if (cvssV2 != null && !cvssV2.isEmpty()) {
            Map<String, Object> cvssData = cvssV2.get(0);
            if (cvssData != null && cvssData.containsKey("baseScore")) {
                return ((Number) cvssData.get("baseScore")).doubleValue();
            }
        }

        return null;
    }

    @Override
    @Transactional
    public void processAndLinkDependencies(Sbom sbom, String dependencyData, Map<String, Long> bomRefToSbomComponentIdMap) {
        log.info("Processing dependencies for SBOM: {}", sbom.getId());
        
        try {
            String[] dependencies = dependencyData.split("\n");
            
            for (String dependency : dependencies) {
                if (dependency.trim().isEmpty()) continue;
                
                String[] parts = dependency.split(":");
                if (parts.length < 2) continue;
                
                String bomRef = parts[0].trim();
                String purl = parts[1].trim();
                
                Long componentId = bomRefToSbomComponentIdMap.get(bomRef);
                if (componentId != null) {
                    Component component = componentRepository.findById(componentId)
                        .orElseThrow(() -> new RuntimeException("Component not found: " + componentId));
                    
                    if (component.getPackageUrl() == null) {
                        component.setPackageUrl(purl);
                        componentRepository.save(component);
                    }
                    
                    ComponentToEnrich componentToEnrich = ComponentToEnrich.builder()
                        .id(component.getId())
                        .name(component.getName())
                        .version(component.getVersion())
                        .type(component.getType())
                        .purl(component.getPackageUrl())
                        .sbomId(sbom.getId())
                        .build();
                    enrichComponent(componentToEnrich, null);
                }
            }
            
            log.info("Completed processing dependencies for SBOM: {}", sbom.getId());
        } catch (Exception e) {
            log.error("Error processing dependencies for SBOM {}: {}", sbom.getId(), e.getMessage(), e);
            throw new RuntimeException("Failed to process dependencies", e);
        }
    }

    private String resolveVendor(Component component) {
        // 1. Try PURL first
        String vendor = extractVendorFromPurl(component.getPackageUrl());
        if (vendor != null && !vendor.equals(component.getName())) {
            log.debug("Found vendor from PURL: {} for component: {}", vendor, component.getName());
            return vendor;
        }
        
        // 2. Try to extract vendor from name
        vendor = extractVendorFromName(component.getName());
        if (vendor != null && !vendor.equals(component.getName())) {
            log.debug("Found vendor from name: {} for component: {}", vendor, component.getName());
            return vendor;
        }
        
        // 3. Apply detection rules
        vendor = detectVendor(component.getName(), component.getType());
        if (vendor != null && !vendor.equals(component.getName())) {
            log.debug("Found vendor from rules: {} for component: {}", vendor, component.getName());
            return vendor;
        }
        
        // 4. Fallback to package name as vendor
        log.debug("Using package name as vendor: {} for component: {}", component.getName(), component.getName());
        return component.getName();
    }

    private String extractVendorFromName(String name) {
        if (name == null) return null;
        
        // Common vendor prefixes
        String[] vendorPrefixes = {
            "@", "org.", "com.", "io.", "net.", "dev.", "github.", "npm:"
        };
        
        for (String prefix : vendorPrefixes) {
            if (name.startsWith(prefix)) {
                String[] parts = name.substring(prefix.length()).split("[/-]");
                if (parts.length > 0) {
                    return parts[0];
                }
            }
        }
        
        // Try to split by common separators
        String[] separators = {"/", "-", "_", "."};
        for (String separator : separators) {
            if (name.contains(separator)) {
                String[] parts = name.split(separator);
                if (parts.length > 0) {
                    return parts[0];
                }
            }
        }
        
        return null;
    }

    private void updateGraphData(Long sbomId) {
        try {
            // Get the build associated with this SBOM
            Build build = buildRepository.findBySbomId(sbomId)
                .orElseThrow(() -> new RuntimeException("Build not found for SBOM: " + sbomId));
            
            // Update the build status to indicate ongoing vulnerability scanning
            build.setStatus(BuildStatus.VULNERABILITY_SCANNING);
            buildRepository.save(build);
            
            log.info("Updated graph data for build: {}", build.getId());
        } catch (Exception e) {
            log.error("Error updating graph data: {}", e.getMessage());
        }
    }
} 